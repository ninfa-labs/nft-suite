// SPDX-License-Identifier: MIT
pragma solidity 0.8.28;

import "./utils/Counters.sol";
import "./utils/RoyaltyEngineV1.sol";
import "./utils/Address.sol";
import "./utils/interfaces/AggregatorV3Interface.sol";
import "./access/Owned.sol";

/**
 * @title OnChainMarketplace
 * @notice NFT marketplace featuring on-chain orders and offers.
 * An order's quote/underlyer currency or token can be set to either ETH or USDC.
 * If the currency/token used to pay is different from the quote one,
 * the exchange rate calculated by the marketplace by using "Chainlink" price feeds.
 *
 * @author cosimo.demedici.eth (https://github.com/ninfa-labs/ninfa-contracts)
 */
contract OnChainMarketplace is Owned, RoyaltyEngineV1 {
    /**
     * @notice utility library for address type
     * @dev The `Address` library is used to check if an address is a contract, and to send ETH to an address.
     */
    using Address for address;
    /**
     * @notice utility library for auto-incrementing Counters
     * @dev functions available for `Counter` type are `.increment()` and `.current()`
     */
    using Counters for Counters.Counter;

    /**
     * @notice Chainlink price feed aggregator interface
     * @dev The price feed is used to determine the price of NFTs in USDC
     */
    AggregatorV3Interface private immutable _dataFeed;

    /**
     * @notice Enum for the type of token used in the marketplace
     */
    enum QuoteToken {
        ETH,
        USDC
    }

    /**
     * @notice the `Order` struct is used both for storing order information, as
     * well as trade information when passed as a
     * function parameter to the private `_handleETHTrade` function
     * @param tokenId collection's token id
     * @param unitPrice ERC-1155 unit price in ETH, or total price for an ERC-721 token.
     * When the `Order` struct is passed as a function parameter to
     * `_handleETHTrade`, `unitPrice` always refers to the
     * total price of ERC-1155 tokens, i.e. token value * unit price
     * @param ERC1155Value the token amount, the quantity of ERC-1155 tokens involved in the order. This value is 0 for
     * ERC-721 tokens, since each ERC-721 token is unique and non-divisible
     * @param collection address of the ERC721 or ERC1155 contract.
     * @param from always refers to the seller, who either creater an order or
     * is accepting an offer.
     * @param operator the address of an authorized operator, who is responsible for creating the order. This is used
     * for access control.
     * @param commissionBps the commission amount for the sale, expressed in basis points (0 - 10000, where
     * 10000 basis
     * points equals 100%)
     * @param commissionRecipient the addresses of the recipients who will receive the commission from the sale. This
     * can include both primary and secondary recipients
     */
    struct Order {
        uint256 tokenId;
        uint256 unitPrice;
        uint256 ERC1155Value;
        address collection;
        address from;
        address operator;
        uint256[] commissionBps;
        address[] commissionRecipient;
    }
    /**
     * @dev Defines an offer for a token in a collection.
     *
     * @param tokenId The ID of the token in the collection.
     * @param unitPrice The price for each token, applicable to both ERC721 and ERC1155 tokens.
     * @param ERC1155Value The value for ERC1155 tokens. A value of 0 indicates an ERC721 token, while a value greater
     * than 0 indicates the amount of ERC1155 tokens.
     * @param collection The address of the NFT contract.
     * @param from The address of the buyer, i.e., the address creating the offer.
     */

    struct Offer {
        uint256 tokenId;
        uint256 unitPrice;
        uint256 ERC1155Value;
        address collection;
        address from;
    }

    /**
     * @notice USDC contract address
     */
    address private immutable _USDC;

    /**
     * @notice 10,000 basis points = 100% shares sale price
     */
    uint256 private constant _TOTAL_BPS = 10_000;

    /**
     * @notice auto-incrementing counter for ETH orders (NFT price is set in ETH)
     */
    Counters.Counter public ETHOrderCount;
    /**
     * @notice auto-incrementing counter for USDC orders (NFT price is set in USDC)
     */
    Counters.Counter public USDCOrderCount;
    /**
     * @notice auto-incrementing counter for ETH offers (NFT offer paid with ETH)
     */
    Counters.Counter public ETHOfferCount;
    /**
     * @notice auto-incrementing counter for USDC offers (NFT offer paid with USDC)
     */
    Counters.Counter public USDCOfferCount;

    /**
     * @notice address for receiving fees generated by the marketplace
     */
    address internal _salesFeeRecipient;

    /**
     * @notice primary market sales fee in basis points
     */
    uint256 internal _salesFeeBps;

    /**
     * @notice mapping from `ETHOrderCount` counter to `Order` struct.
     * @dev `_ETHOrders` needs an explicit getter function in order to return the content of its arrays, see
     * `getETHOrder()`
     */
    mapping(uint256 => Order) private _ETHOrders;
    /**
     * @notice mapping from `USDCOrderCount` counter to `Order` struct.
     * @dev `_USDCOrders` needs an explicit getter function in order to return the content of its arrays, see
     * `getUSDCOrder()`
     */
    mapping(uint256 => Order) private _USDCOrders;
    /**
     * @notice mapping from `ETHOfferCount` counter to `Offer` struct.
     * @dev `_ETHOffers` needs an explicit getter function in order to return the content of its arrays, see
     * `getETHOffer()`
     */
    mapping(uint256 => Offer) private _ETHOffers;
    /**
     * @notice mapping from `USDCOfferCount` counter to `Offer` struct.
     * @dev `_USDCOffers` needs an explicit getter function in order to return the content of its arrays, see
     * `getUSDCOffer()`
     */
    mapping(uint256 => Offer) private _USDCOffers;

    /**
     * @notice Emitted when a new order is created, includes the ID of the new order.
     * @param orderId The ID of the new order.
     * @param quoteToken The token used to quote the price of the NFT.
     */
    event OrderCreated(uint256 orderId, QuoteToken quoteToken);
    /**
     * @notice Emitted when an existing order is updated, includes the ID of the updated order.
     * @param orderId The ID of the updated order.
     * @param quoteToken The token used to quote the price of the NFT.
     */
    event OrderUpdated(uint256 orderId, QuoteToken quoteToken);
    /**
     * @notice Emitted when an order is deleted, includes the ID of the deleted order.
     * @param orderId The ID of the deleted order.
     * @param quoteToken The token used to quote the price of the NFT.
     */
    event OrderDeleted(uint256 orderId, QuoteToken quoteToken);
    /**
     * @notice Emitted when a new offer is created, includes the ID of the new offer.
     * @param offerId The ID of the new offer.
     * @param quoteToken The token used to quote the price of the NFT.
     */
    event OfferCreated(uint256 offerId, QuoteToken quoteToken);
    /**
     * @notice Emitted when an existing offer is updated, includes the ID of the updated offer.
     * @param offerId The ID of the updated offer.
     * @param quoteToken The token used to quote the price of the NFT.
     */
    event OfferUpdated(uint256 offerId, QuoteToken quoteToken);
    /**
     * @notice Emitted when an offer is deleted, includes the ID of the deleted offer.
     * @param offerId The ID of the deleted offer.
     * @param quoteToken The token used to quote the price of the NFT.
     */
    event OfferDeleted(uint256 offerId, QuoteToken quoteToken);
    /**
     * @notice This event is emitted when a trade occurs.
     * @dev It is needed because once an order/offer is filled, it is deleted from storage.
     * Hence backends cannot read data using public getters after the event has been emitted.
     * @param collection The address of the NFT collection.
     * @param tokenId The ID of the token traded.
     * @param from The address of the seller of the NFT.
     * @param id The ID of the order or offer.
     * @param price The total ETH value transacted.
     * @param ERC1155Value The value for ERC1155 tokens. It is 0 for ERC721 and >1 for ERC1155.
     * @param quoteToken The token used to quote the price of the NFT.
     */
    event Trade(
        address indexed collection,
        address indexed from,
        uint256 indexed tokenId,
        uint256 id,
        uint256 price,
        uint256 ERC1155Value,
        QuoteToken quoteToken
    );

    /**
     * @notice Constructor for the OnChainMarketplace contract
     * @dev Initializes the contract with a fee recipient and fee basis points
     * @param feeRecipient_ The address controlled by Ninfa that will receive any market fees
     * @param _salesFeeBps_ The fee in basis points
     */
    constructor(address USDC_, address ETHUSDPriceFeed_, address feeRecipient_, uint256 _salesFeeBps_) {
        _USDC = USDC_;
        _dataFeed = AggregatorV3Interface(ETHUSDPriceFeed_);
        owner = msg.sender;
        _salesFeeRecipient = feeRecipient_;
        _salesFeeBps = _salesFeeBps_;
    }

    /**
     * @notice This function is called whenever an {IERC721} `tokenId` token is transferred to this contract via
     * {IERC721-safeTransferFrom} by `operator` from `from`.
     * @dev It must return its Solidity selector to confirm the token transfer. If any other value is returned or the
     * interface is not implemented by the recipient, the transfer will be reverted. The selector can be obtained in
     * Solidity with `IERC721.onERC721Received.selector`.
     * @param _operator The address which called `safeTransferFrom` function
     * @param _from The address which previously owned the token
     * @param _tokenId The NFT identifier which is being transferred
     * @param _data Additional data with no specified format, decoded to offerId, unitPrice, commissionBps, and
     * commissionRecipient
     * @return bytes4 `0x150b7a02` to confirm the token transfer
     */
    function onERC721Received(
        address _operator,
        address _from,
        uint256 _tokenId,
        bytes calldata _data
    )
        external
        returns (bytes4)
    {
        (
            uint256 offerId,
            uint256 unitPrice,
            uint256[] memory commissionBps,
            address[] memory commissionRecipients,
            QuoteToken quoteToken
        ) = abi.decode(_data, (uint256, uint256, uint256[], address[], QuoteToken));

        if (offerId == 0) {
            // if the offer id parameter is 0, create a new order
            /*----------------------------------------------------------*|
            |*  # CREATE ORDER                                          *|
            |*----------------------------------------------------------*/
            // if `_orderOrOfferId` is 0, create a new order, i.e.:
            // `_unitPrice >= 0 && _offerId == 0`
            quoteToken == QuoteToken.ETH
                ? _createETHOrder(_operator, _from, _tokenId, 0, unitPrice, commissionBps, commissionRecipients)
                : _createUSDCOrder(_operator, _from, _tokenId, 0, unitPrice, commissionBps, commissionRecipients);
        } else {
            /*----------------------------------------------------------*|
            |*  # ACCEPT OFFER                                          *|
            |*----------------------------------------------------------*/
            Offer memory offer;

            if (quoteToken == QuoteToken.ETH) {
                offer = _ETHOffers[offerId]; // if the offer is in ETH
                // since the function is public `msg.sender` must be the same contract address as the one specified by
                // the offer id being accepted.
                // Having verified the collection, verifying the remaining hook's function parameters is not needed,
                // since the it is assumed that they are not user controlled except for `_data` which can be arbitrary.
                require(offer.collection == msg.sender && offer.tokenId == _tokenId);

                delete _ETHOffers[offerId]; // ERC-721 doesn't have any supply therefore the offer may be deleted
                emit OfferDeleted(offerId, quoteToken);

                _handleETHTrade(
                    Order(
                        _tokenId, // uint256 tokenId
                        offer.unitPrice, // uint256 price
                        offer.ERC1155Value,
                        msg.sender, // address collection
                        _from, // seller (order.from)
                        offer.from, // buyer (order.operator)
                        commissionBps, // uint256 _commissionBps
                        commissionRecipients
                    ),
                    offerId
                );
            } else {
                offer = _USDCOffers[offerId]; // if the offer is in USDC
                // since the function is public `msg.sender` must be the same contract address as the one specified by
                // the offer id being accepted.
                // Having verified the collection, verifying the remaining hook's function parameters is not needed,
                // since the it is assumed that they are not user controlled except for `_data` which can be arbitrary.
                require(offer.collection == msg.sender && offer.tokenId == _tokenId);
                delete _USDCOffers[offerId]; // ERC-721 doesn't have any supply therefore the offer may be deleted
                emit OfferDeleted(offerId, quoteToken);

                _handleUSDCTrade(
                    Order(
                        _tokenId, // uint256 tokenId
                        offer.unitPrice, // uint256 price
                        offer.ERC1155Value,
                        msg.sender, // address collection
                        _from, // seller (order.from)
                        offer.from, // buyer (order.operator)
                        commissionBps, // uint256 _commissionBps
                        commissionRecipients
                    ),
                    offerId
                );
            }
        }

        return 0x150b7a02;
    }

    /**
     * @notice Handles the receipt of a single ERC1155 token type.
     * @dev This function is called at the end of a `safeTransferFrom` after the balance has been updated.
     * To accept the transfer, this must return
     * `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` (i.e. 0xf23a6e61, or its own
     * function selector).
     * @param _operator The address which initiated the transfer (i.e. msg.sender or whoever called safeTransferFrom on
     * the ERC1155 contract)
     * @param _from The address which previously owned the token
     * @param _tokenId The ID of the token being transferred
     * @param _value The amount of tokens being transferred
     * @param _data Additional data with no specified format
     * @return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` if transfer is allowed
     */
    function onERC1155Received(
        address _operator,
        address _from, // previous owner
        uint256 _tokenId,
        uint256 _value,
        bytes memory _data
    )
        external
        returns (bytes4)
    {
        /**
         * @param orderOrOfferId corresponding to an order to be updated or an offer to be accepted, if the
         * `orderOrOfferId` parameter is 0
         * create a new order.
         * @param unitPrice if an order is created this is the unit price stored in the new order.
         * In order to update orders via this hook unitPrice MUST be greater than 0, even if no price change is needed,
         * in which case encode the current order.unitPrice.
         * Since this function is used for receiving erc1155 tokens, it is most likely that the order's operator just
         * wants to raise the erc1155 value,
         * however, unitPrice allows to set a new unit price in the same function call if needed, just in case.
         * @param commissionBps commission BPS, i.e. a way to split the profit from sales with other addresses.
         * @param commissionRecipient address(es) for receiving sale commissions.
         */
        (
            uint256 orderOrOfferId,
            uint256 unitPrice,
            uint256[] memory commissionBps,
            address[] memory commissionRecipients,
            QuoteToken quoteToken
        ) = abi.decode(_data, (uint256, uint256, uint256[], address[], QuoteToken));

        _handleERC1155OrderOrOffer(
            _from,
            _operator,
            commissionRecipients,
            orderOrOfferId,
            unitPrice,
            _value,
            _tokenId,
            commissionBps,
            quoteToken
        );

        return 0xf23a6e61;
    }

    function onERC1155BatchReceived(
        address _operator,
        address _from,
        uint256[] calldata _ids,
        uint256[] calldata _values,
        bytes calldata _data
    )
        external
        returns (bytes4)
    {
        /// @dev comparing array length of `_data` and `_ids` is not needed as it is not an exploitable flaw, this saves
        /// gas to the user
        /// i.e. `require((len1 ^ len2 ^ len3 ^ len4) == 0, "Array lengths are not equal");`
        (
            uint256[] memory orderOrOfferIds,
            uint256[] memory unitPrices,
            uint256[] memory commissionBps,
            address[] memory commissionRecipients,
            QuoteToken[] memory quoteTokens
        ) = abi.decode(_data, (uint256[], uint256[], uint256[], address[], QuoteToken[]));

        for (uint256 i = _ids.length; i > 0; i--) {
            _handleERC1155OrderOrOffer(
                _from,
                _operator,
                commissionRecipients,
                orderOrOfferIds[i],
                unitPrices[i],
                _values[i],
                _ids[i],
                commissionBps,
                quoteTokens[i]
            );
        }

        return 0xbc197c81;
    }

    /**
     * @notice The collector calls this function to buy an NFT at the ask price, only if an order exists.
     * @dev If someone has an open offer but calls fillETHOrder, the offer will remain open. They will need to
     * call cancelOffer() to get a refund. This is unlikely, as users will likely be aware of this and use the refund in
     * order to pay for part of the order.
     * @param _id This parameter avoids having to store a mapping to order id like the deprecated
     * `mapping(address => mapping(uint256 => uint256)) private _tokenToOrderId` which would not have worked for
     * erc1155 as each token has a supply. _orderId does not constitute a vulnerability as it is user provided,
     * since a regular user will go through the frontend which gets orderId from events.
     * @param _buyer This parameter is needed in order to integrate Wert payment solution, because in every txn Wert is
     * the msg.sender,
     * although using msg.sender would cost less gas. It is possible for the buyer to use this
     * parameter simply in order to transfer the NFT to an address other than their own, this can be useful for external
     * contract buying NFTs.
     * @param _ERC1155Value This is the market order amount (total or partial fill). `_ERC1155Value == 0` corresponds to
     * one erc721 tokenId, `_ERC1155Value > 0` for erc1155 tokenIds.
     * @dev MUST: `msg.value` must be equal to `_ETHOrders[_orderId].unitPrice * buyAmount` and
     * `_ETHOrders[_orderId].sellAmount >= buyAmount`.
     */
    function fillETHOrder(uint256 _id, address _buyer, uint256 _ERC1155Value) external payable {
        Order memory order = _ETHOrders[_id];

        order.operator = _buyer;

        if (_ERC1155Value == 0) {
            // if ERC-721 token
            delete _ETHOrders[_id];
            emit OrderDeleted(_id, QuoteToken.ETH);
        } else {
            // if ERC-1155 token
            // set custom values for memory order, to be used by `_handleETHTrade()`
            // needed because not all internal calls to `_handleETHTrade` have a `msg.value` parameter, i.e.
            // `acceptOffer` and `fillUSDOrder`
            order.unitPrice *= _ERC1155Value;
            // subtracting user-suplied `_ERC1155Value` from order amount with inline assignment,
            // transaction will revert if underflow
            if ((_ETHOrders[_id].ERC1155Value -= _ERC1155Value) == 0) {
                delete _ETHOrders[_id];
                emit OrderDeleted(_id, QuoteToken.ETH);
            } else {
                // if _ERC1155Value is different from order.ERC1155Value, i.e. partial fill
                // reassigning order.ERC1155Value to user-supplied _ERC1155Value
                order.ERC1155Value = _ERC1155Value;
            }
        }

        if (msg.value > 0) {
            require(msg.value == order.unitPrice);

            _handleETHTrade(order, _id);
        } else {
            (, int256 answer,,,) = _dataFeed.latestRoundData();
            // Adjust for price feed decimals i.e. `1e8` by truncating the last 2 digits before continuing
            // this does not affect precision since USDC has 6 decimals, but the price feed returns 8 decimals
            order.unitPrice = uint256(answer) / 100 * order.unitPrice / 1 ether;
            _handleUSDCTrade(order, _id);
        }
    }

    /**
     * @notice The collector calls this function to buy an NFT at the ask price, only if an order exists.
     * @dev If someone has an open offer but calls fillUSDCOrder, the offer will remain open. They will need to
     * call cancelOffer() to get a refund. This is unlikely, as users will likely be aware of this and use the refund in
     */
    function fillUSDCOrder(uint256 _id, address _buyer, uint256 _ERC1155Value) external payable {
        Order memory order = _USDCOrders[_id];

        order.operator = _buyer;

        if (_ERC1155Value == 0) {
            // if ERC-721 token
            delete _USDCOrders[_id];
            emit OrderDeleted(_id, QuoteToken.USDC);
        } else {
            // if ERC-1155 token
            // set custom values for memory order, to be used by `_handleETHTrade()`
            // also needed un order to check msg.value == order.unitPrice * _ERC1155Value in case of ETH fill
            order.unitPrice *= _ERC1155Value;
            // subtracting user-suplied `_ERC1155Value` from order amount with inline assignment,
            // transaction will revert if underflow
            if ((_USDCOrders[_id].ERC1155Value -= _ERC1155Value) == 0) {
                delete _USDCOrders[_id];
                emit OrderDeleted(_id, QuoteToken.USDC);
            } else {
                // if _ERC1155Value is different from order.ERC1155Value, i.e. partial fill
                // reassigning order.ERC1155Value to user-supplied _ERC1155Value
                order.ERC1155Value = _ERC1155Value;
            }
        }

        if (msg.value > 0) {
            (, int256 answer,,,) = _dataFeed.latestRoundData();
            // Adjust for price feed decimals i.e. `1e8` by truncating the last 2 digits before continuing
            // this does not affect precision since USDC has 6 decimals, but the price feed returns 8 decimals
            order.unitPrice = uint256(answer) / 100 * order.unitPrice / 1 ether;
            // this require statement MUST be placed after the price feed adjustment rather than before, in order to
            // compare ETH to ETH values rather than ETH to USDC values, since the quote token is USDC.
            // there is a slim chance that the price feed will update between the moment the transaction is created via
            // the frontend and the moment it broadcasts to the network, meaning the transaction will revert.
            require(msg.value == order.unitPrice);

            _handleETHTrade(order, _id);
        } else {
            // Payment in USDC
            _handleUSDCTrade(order, _id);
        }
    }

    /**
     * @notice This function allows users to create offers for NFTs.
     * @dev Offers can be made independently of whether the token is on sale or not. The msg.value is used to determine
     * the offer amount, so no function parameter is needed for that.
     * @param _tokenId The token id for which the offer is made.
     * @param _unitPrice Price for each ERC721 or ERC1155 token. If ERC1155, then msg.value must equal _unitPrice *
     * _ERC1155Value.
     * @param _ERC1155Value The token value desired. _ERC1155Value == 0 for ERC721 and _ERC1155Value > 0 for ERC1155.
     * @param _collection Address of the NFT implementation or proxy contract.
     * @param _from This parameter is mainly needed in order to integrate third-party credit card payment providers, as
     * in every transaction the payment provider's contract is the `msg.sender`. The buyer may also use this parameter
     * simply in order to transfer the NFT to an address other than their own.
     */
    function createOffer(
        uint256 _tokenId,
        uint256 _unitPrice,
        uint256 _ERC1155Value,
        address _collection,
        address _from
    )
        external
        payable
    {
        uint256 offerValue = _unitPrice;
        // implicitly require that total sum of offers value is equal to msg.value,
        // care must be taken to calculate the correct ETH amount or any leftover amount sent is going to be stuck in
        // this contract
        // if `_ERC1155Value > 1`, avoids multiplying `unitPrice` by 1 unnecessarily in case `_ERC1155Values[i] == 1`.
        if (_ERC1155Value > 1) offerValue *= _ERC1155Value;

        /// @dev checking that `msg.value == _unitPrice` saves gas as it removes the need for the statement
        /// `require(msg.value == _unitPrice)`, which would have to be added if the below if check read `msg.value > 0`
        /// instead.
        /// this implies that if msg.value is different from the specified _unitPrice, the execution flow will enter the
        /// `else` block and attempt to transfer `_unitValue` worth of USDC to this contract, which will revert due to
        /// "insufficient balance" as ethereum has 18 decimals whereas USDC only has 6.
        offerValue == msg.value
            ? _createETHOffer(_tokenId, _unitPrice, _ERC1155Value, _collection, _from)
            : _createUSDCOffer(_tokenId, _unitPrice, _ERC1155Value, offerValue, _collection, _from);
    }

    function createMultiOffer(
        uint256[] memory _tokenIds,
        uint256[] memory _unitPrices,
        uint256[] memory _ERC1155Values,
        address[] memory _collections,
        address _from
    )
        external
        payable
    {
        // length of arrays, used to check if all arrays are of the same length and to iterate over them
        uint256 i = _tokenIds.length;
        // value counter used to check if msg.value is equal to the sum of all order.unitPrice * _ERC1155Values
        // counter for ETH msg.value available to spend
        uint256 ETHCredit = msg.value;
        uint256 offerValue;

        /// @dev XOR-ing the same numbers will cancel them out to 0. If any pair is not equal, the XOR will not be zero.
        require((i ^ _unitPrices.length ^ _ERC1155Values.length ^ _collections.length) == 0);

        if (ETHCredit > 0) {
            do {
                --i;

                offerValue = _unitPrices[i];
                // implicitly require that total sum of offers value is equal to msg.value,
                // care must be taken to calculate the correct ETH amount or any leftover amount sent is going to be
                // stuck in this contract
                if (_ERC1155Values[i] > 1) offerValue *= _ERC1155Values[i];

                ETHCredit -= offerValue;

                _createETHOffer(_tokenIds[i], _unitPrices[i], _ERC1155Values[i], _collections[i], _from);
            } while (i > 0);
        } else {
            do {
                --i;

                offerValue = _unitPrices[i];
                // implicitly require that total sum of offers value is equal to msg.value,
                // care must be taken to calculate the correct ETH amount or any leftover amount sent is going to be
                // stuck in this contract
                if (_ERC1155Values[i] > 1) offerValue *= _ERC1155Values[i];
            } while (i > 0);
        }
    }

    /**
     * @notice Called when a seller accepts an offer for a token that is on escrow on the marketplace. Commissions if
     * any are set on the corresponding sell order.
     * @dev This function allows partial fills of offers. For ERC1155 tokens, the requested offer token
     * value does not have to be fulfilled in its entirety.
     * @param _ERC1155Value Specifies the token value to sell from the order for partial fills of offers.
     * It must be set to a positive integer for offers on ERC1155 tokens and left as 0 for ERC721 tokens.
     * However, it cannot be greater than the offer's token value itself.
     * @param _orderId The ID of the order.
     * @param _offerId The ID of the offer.
     */
    function acceptETHOffer(uint256 _orderId, uint256 _offerId, uint256 _ERC1155Value) external {
        Order memory order = _ETHOrders[_orderId];
        Offer memory offer = _ETHOffers[_offerId];
        // collection and tokenId of the NFT received by the
        // marketplace must match the ones stored at
        // the _orderOrOfferId provided by the operator
        // in order to avoid operators increasing allowance for orders with
        // different (more valuable) token ids from the same collection.
        require(
            order.operator == msg.sender // order.operator is used purely for access control throughout contract, seller
                // is order.from
                && order.tokenId == offer.tokenId // as long as collection and token id are the same the offer may be
                // accepted
                && order.collection == offer.collection
        );

        if (order.ERC1155Value > 0) {
            // it may be possible for `_ERC1155Value` to be 0, though, which reuires checking for a positive
            // ERC1155Value in order to avoid attacks which may snipe ERC1155 tokens escrowed in the marketplace
            // contract. I.e. the attacker is both order and offer creator, ERC1155Value remains the same as 0 is
            // subtracted from storage yet the marketplace transfers any tokens it owns deposited by other accounts.
            if (_ERC1155Value == 0) revert();
            // buyer's _ERC1155Value cannot exceed order.ERC1155Value. Inline subtraction prevents underflow errors.
            _ETHOrders[_orderId].ERC1155Value -= _ERC1155Value;
            // buyer's _ERC1155Value cannot exceed offer.ERC1155Value. Inline subtraction prevents underflow errors.
            _ETHOffers[_offerId].ERC1155Value -= _ERC1155Value;
            // inline multiplication assigns the total price to the `memory` order.unitPrice
            order.unitPrice = offer.unitPrice * _ERC1155Value;
        }

        if (_ETHOrders[_orderId].ERC1155Value == 0) {
            // orders and offers can be partially filled, check separately if the value is 0, delete the order or offer.
            delete _ETHOrders[_orderId];
            emit OrderDeleted(_orderId, QuoteToken.ETH);
        } else {
            // if even after subtracting `_ERC1155Value` from `_ETHOrders` order, the value is more than 0, that means
            // that
            // the order is partially filled and hence we must assign the user input `_ERC1155Value` to the `memory`
            // order
            // struct passed to the payment handling function.
            // since there is no risk of underflow at this point, the user input `_ERC1155Value` is safe to be assigned
            // to
            // the `memory` copy of `order.ERC1155Value`, which we can assume is less than `order.ERC1155Value` AND less
            // than `offer.ERC1155Value`.
            order.ERC1155Value = _ERC1155Value;
        }

        if (_ETHOffers[_offerId].ERC1155Value == 0) {
            // orders and offers can be partially filled, check separately if the value is 0, delete the order or offer.
            delete _ETHOffers[_offerId];
            emit OfferDeleted(_offerId, QuoteToken.ETH);
        }

        // needed for convenience in order to pass `order` struct to payment handling function
        order.operator = offer.from;

        _handleETHTrade(order, _offerId);
    }

    function acceptUSDCOffer(
        uint256 _orderId,
        uint256 _offerId,
        uint256 _ERC1155Value,
        uint256[] memory _commissionBps,
        address[] memory _commissionRecipient
    )
        external
    {
        Order memory order = _USDCOrders[_orderId];
        Offer memory offer = _USDCOffers[_offerId];

        uint256 offerValue = offer.unitPrice;
        // collection and tokenId of the NFT received by the
        // marketplace must match the ones stored at
        // the _orderOrOfferId provided by the operator
        // in order to avoid operators increasing allowance for orders with
        // different (more valuable) token ids from the same collection.
        require(
            order.operator == msg.sender // order.operator is used purely for access control throughout contract, seller
                // is order.from
                && order.tokenId == offer.tokenId // as long as collection and token id are the same the offer may be
                // accepted
                && order.collection == offer.collection
        );
        if (order.ERC1155Value > 0) {
            // inline multiplication assigns the total price to the `memory` order.unitPrice
            offer.unitPrice *= _ERC1155Value;
            // buyer's _ERC1155Value cannot exceed order.ERC1155Value. Inline subtraction prevents reentrancy attacks.
            _USDCOrders[_orderId].ERC1155Value -= _ERC1155Value;
            // buyer's _ERC1155Value cannot exceed offer.ERC1155Value. Inline subtraction prevents reentrancy attacks.
            _USDCOffers[_offerId].ERC1155Value -= _ERC1155Value;
        }
        // orders and offers can be partially filled, check separately if the value is 0, delete the order or offer.
        if (_USDCOrders[_orderId].ERC1155Value == 0) {
            delete _USDCOrders[_orderId];
            emit OrderDeleted(_orderId, QuoteToken.USDC);
        }

        if (_USDCOffers[_offerId].ERC1155Value == 0) {
            delete _USDCOffers[_offerId];
            emit OfferDeleted(_offerId, QuoteToken.USDC);
        }

        _handleUSDCTrade(
            Order(
                order.tokenId,
                offerValue, // total price (unitPrice * value)
                offer.ERC1155Value,
                order.collection,
                order.from, // seller (order.from), profits after fees are sent to this address
                offer.from, // buyer (order.operator)
                _commissionBps,
                _commissionRecipient
            ),
            _offerId
        );
    }

    /**
     * @notice Cancels an offer and refunds ETH back to the bidder.
     * @dev When an order gets filled, the offer isn't marked as cancelled,
     * in order to allow users to claim back their money.
     * @param _offerId The ID of the offer.
     */
    function deleteETHOffer(uint256 _offerId) external {
        Offer memory offer = _ETHOffers[_offerId];

        require(msg.sender == offer.from);

        uint256 refund;

        offer.ERC1155Value == 0 ? refund = offer.unitPrice : refund = offer.unitPrice * offer.ERC1155Value;
        // mark offer as cancelled forever, updating offer price before external call
        delete _ETHOffers[_offerId];
        emit OfferDeleted(_offerId, QuoteToken.ETH);
        // transfer the offer amount back to bidder
        offer.from.sendValue(refund);
    }

    /**
     * @notice Cancels an offer and refunds USDC back to the bidder.
     * @dev When an order gets filled, the offer isn't marked as cancelled,
     * in order to allow users to claim back their money.
     * @param _offerId The ID of the offer.
     */
    function deleteUSDCOffer(uint256 _offerId) external {
        Offer memory offer = _USDCOffers[_offerId];

        require(msg.sender == offer.from);

        uint256 refund;

        offer.ERC1155Value == 0 ? refund = offer.unitPrice : refund = offer.unitPrice * offer.ERC1155Value;

        delete _USDCOffers[_offerId];

        emit OfferDeleted(_offerId, QuoteToken.USDC);

        _USDC.transferFrom(address(this), offer.from, refund);
    }

    /**
     * @notice Raises the price of an existing offer.
     * @dev This is one of two functions called by a buyer to modify their offer.
     * The other function is `lowerOffer()`. This function requires a `msg.value`
     * which will be added to the old offer amount. The frontend needs to calculate
     * the difference between the old and new offer.
     * @param _offerId The ID of the offer.
     * @param _newERC1155Value The new value for the ERC1155 token.
     * @param _newUnitPrice The new unit price.
     */
    function raiseETHOfferPrice(uint256 _offerId, uint256 _newERC1155Value, uint256 _newUnitPrice) external payable {
        Offer storage offer = _ETHOffers[_offerId];

        require(msg.sender == offer.from);

        if (offer.ERC1155Value == 0) {
            // this ensures that the new unit price is greater than or equal to the old
            require(msg.value == _newUnitPrice - offer.unitPrice);
        } else {
            // require that `msg.value` equals the new total offer ETH value minus the old total offer ETH value
            require(msg.value == (_newUnitPrice * _newERC1155Value) - (offer.unitPrice * offer.ERC1155Value));
            // old ERC1155 value is overwritten with new one, doesn't matter if it is more or less,
            // as long as when multiplied by the new unit price it is greater or equal than the old total offer value
            offer.ERC1155Value = _newERC1155Value;
        }

        offer.unitPrice = _newUnitPrice;

        emit OfferUpdated(_offerId, QuoteToken.ETH);
    }

    function raiseUSDCOfferPrice(uint256 _offerId, uint256 _newERC1155Value, uint256 _newUnitPrice) external {
        Offer storage offer = _USDCOffers[_offerId];

        require(msg.sender == offer.from);

        // if the old and new ERC1155 values are the same, the user is only raising the unit price, not the value,
        // therefore it is either an ERC721 token or the user is not changing the value of the ERC1155 token
        // else the user is changing the value of the ERC1155 token
        if (offer.ERC1155Value == 0) {
            // this ensures that the new unit price is greater than or equal to the old
            _USDC.transferFrom(msg.sender, address(this), _newUnitPrice - offer.unitPrice);
        } else {
            // require that `msg.value` equals the new total offer ETH value minus the old total offer ETH value
            _USDC.transferFrom(
                msg.sender, address(this), (_newUnitPrice * _newERC1155Value) - (offer.unitPrice * offer.ERC1155Value)
            );
            // old ERC1155 value is overwritten with new one, doesn't matter if it is more or less,
            // as long as when multiplied by the new unit price it is greater or equal than the old total offer value
            offer.ERC1155Value = _newERC1155Value;
        }
        // we assume that `_newUnitPrice` is greater than `oldUnitPrice` and unlikely to stay the same,
        // therefore we omit checking whether the new unit price is equal to the old unit price and just update it even
        // if it is the same
        offer.unitPrice = _newUnitPrice;

        emit OfferUpdated(_offerId, QuoteToken.USDC);
    }

    /**
     * @notice Lowers the price of an existing offer.
     * @dev This is one of two functions called by a buyer to modify their offer.
     * The other function is `raiseOffer()`. This function requires a uint parameter
     * representing the new (lower) offer; the buyer will get refunded the difference.
     * @param _offerId The ID of the offer.
     * @param _newERC1155Value The new amount for the ERC1155 token.
     * @param _newUnitPrice The new unit price.
     */
    function lowerETHOfferPrice(uint256 _offerId, uint256 _newERC1155Value, uint256 _newUnitPrice) external {
        Offer storage offer = _ETHOffers[_offerId];

        require(msg.sender == offer.from);

        uint256 refund;

        if (_newERC1155Value == 0) {
            // if ERC-721 token
            // calculate the difference between the old and new lower offer
            refund = offer.unitPrice - _newUnitPrice;
        } else {
            // if ERC-1155 token
            // calculate the difference between the old and new lower offer multiplied by the ERC1155 value.
            // Both new and old unit prices need to be multiplied by the ERC1155 value to get the total offer value,
            // even if offer.ERC1155Value hasn't changed (_newERC1155Value == offer.ERC1155Value)
            refund = (offer.unitPrice * offer.ERC1155Value) - (_newUnitPrice * _newERC1155Value);
            offer.ERC1155Value = _newERC1155Value;
        }

        offer.unitPrice = _newUnitPrice; // needed to store result before offer
            // price is updated
        // transfer the difference between old and new lower offer to the user
        offer.from.sendValue(refund);

        emit OfferUpdated(_offerId, QuoteToken.ETH);
    }

    function lowerUSDCOfferPrice(uint256 _offerId, uint256 _newERC1155Value, uint256 _newUnitPrice) external {
        Offer storage offer = _USDCOffers[_offerId];

        require(msg.sender == offer.from);

        uint256 refund;

        if (_newERC1155Value == 0) {
            refund = offer.unitPrice - _newUnitPrice;
        } else {
            refund = (offer.unitPrice * offer.ERC1155Value) - (_newUnitPrice * _newERC1155Value);
            offer.ERC1155Value = _newERC1155Value;
        }

        offer.unitPrice = _newUnitPrice; // needed to store result before offer
            // price is updated
        // transfer the difference between old and new lower offer to the user
        _USDC.transferFrom(address(this), offer.from, refund);

        emit OfferUpdated(_offerId, QuoteToken.USDC);
    }

    /**
     * @dev Updates or sets the order's unit price and value of ERC1155 token. This function is only for ERC1155.
     * To increase the order's value, call `onERC1155Received` via the `safeTransferFrom` function of the ERC1155 token.
     * @param _ERC1155RedeemAmount The amount of ERC1155 token value to redeem, i.e., subtract from the order.
     *     // if the order is an ERC721 token, there is no _ERC1155RedeemAmount, in order to withdraw the token
     * `deleteOrder` should be called
     * @param _newUnitPrice The new unit price that will replace the old one. It can be set to 0, but this might
     * indicate a mistake by the seller.
     * @param _orderId The ID of the order to update.
     */
    function updateETHOrder(uint256 _orderId, uint256 _ERC1155RedeemAmount, uint256 _newUnitPrice) external {
        Order storage order = _ETHOrders[_orderId];

        require(msg.sender == order.operator);

        if (_ERC1155RedeemAmount > 0) {
            /// @dev warning, make changes to storage BEFORE making external calls
            /// for transfering the NFT back to the
            /// seller (check-effects-interactions pattern)
            order.ERC1155Value -= _ERC1155RedeemAmount;
            // if ERC1155 token
            // transfer ERC1155 token back to seller
            (bool success,) = order.collection.call(
                abi.encodeWithSelector(
                    0xf242432a, // bytes4(keccak256('safeTransferFrom(address,address,uint256,uint256,bytes)'))
                    address(this),
                    msg.sender,
                    order.tokenId,
                    _ERC1155RedeemAmount,
                    ""
                )
            );
            require(success);
        }
        // assuming that `_newUnitPrice` is going to be different from the old one and unlikely to stay the same,
        // therefore we omit checking whether the new unit price is equal to the old unit price and just update it

        order.unitPrice = _newUnitPrice;

        emit OrderUpdated(_orderId, QuoteToken.ETH);
    }

    function updateUSDCOrder(uint256 _orderId, uint256 _erc1155RedeemAmount, uint256 _newUnitPrice) external {
        Order storage order = _USDCOrders[_orderId];

        require(msg.sender == order.operator);

        if (_erc1155RedeemAmount > 0) {
            /// @dev warning, make changes to storage BEFORE making external calls
            /// for transfering the NFT back to the
            /// seller (check-effects-interactions pattern)
            order.ERC1155Value -= _erc1155RedeemAmount;
            // if ERC1155 token
            // transfer ERC1155 token back to seller
            (bool success,) = order.collection.call(
                abi.encodeWithSelector(
                    0xf242432a, // bytes4(keccak256('safeTransferFrom(address,address,uint256,uint256,bytes)'))
                    address(this),
                    msg.sender,
                    order.tokenId,
                    _erc1155RedeemAmount,
                    ""
                )
            );
            require(success);
        }
        // assuming that `_newUnitPrice` is going to be different from the old one and unlikely to stay the same,
        // therefore we omit checking whether the new unit price is equal to the old unit price and just update it
        order.unitPrice = _newUnitPrice;

        emit OrderUpdated(_orderId, QuoteToken.USDC);
    }

    /**
     * @notice Cancels an order and transfers the NFT back to the owner.
     * @param _orderId The ID of the order to cancel.
     * @dev Deletes `_ETHOrders[_orderId]` from storage before making external calls to transfer the NFT back to the
     * seller. This follows the check-effects-interactions pattern.
     * This function does not check whether the order exists or not.
     */
    function deleteETHOrder(uint256 _orderId) external {
        Order memory order = _ETHOrders[_orderId];

        require(msg.sender == order.operator);

        delete _ETHOrders[_orderId];

        emit OrderDeleted(_orderId, QuoteToken.ETH);

        _transferNFT(order.collection, address(this), msg.sender, order.tokenId, order.ERC1155Value);
    }

    /**
     * @notice Cancels an order and transfers the NFT back to the owner.
     * @param _orderId The ID of the order to cancel.
     * @dev Deletes `_USDCOrders[_orderId]` from storage before making external calls to transfer the NFT back to the
     * seller. This follows the check-effects-interactions pattern.
     * This function does not check whether the order exists or not.
     */
    function deleteUSDCOrder(uint256 _orderId) external {
        Order memory order = _USDCOrders[_orderId];

        require(msg.sender == order.operator);

        delete _USDCOrders[_orderId];

        emit OrderDeleted(_orderId, QuoteToken.USDC);

        _transferNFT(order.collection, address(this), msg.sender, order.tokenId, order.ERC1155Value);
    }

    /**
     * @dev Sets the commission for an order.
     * @param _orderId The ID of the order to update.
     * @param _commissionBps The commission rates in basis points.
     * @param _commissionRecipient The addresses of the commission receivers.
     * This function does not check if the total commission is less than 10000. This should revert in the trade function
     * anyway.
     */
    function updateETHOrderCommission(
        uint256 _orderId,
        uint256[] memory _commissionBps,
        address[] memory _commissionRecipient
    )
        external
    {
        require(msg.sender == _ETHOrders[_orderId].operator);
        _ETHOrders[_orderId].commissionBps = _commissionBps;
        _ETHOrders[_orderId].commissionRecipient = _commissionRecipient;
        emit OrderUpdated(_orderId, QuoteToken.ETH);
    }

    function updateUSDCOrderCommission(
        uint256 _orderId,
        uint256[] memory _commissionBps,
        address[] memory _commissionRecipient
    )
        external
    {
        require(msg.sender == _USDCOrders[_orderId].operator);
        _USDCOrders[_orderId].commissionBps = _commissionBps;
        _USDCOrders[_orderId].commissionRecipient = _commissionRecipient;
        emit OrderUpdated(_orderId, QuoteToken.USDC);
    }

    /**
     * @dev Setter function only callable by contract admin. Used to change the
     * address to which fees are paid.
     * @param _newFeeRecipient The address owned by NINFA that will collect
     * sales fees.
     */
    function setFeeRecipient(address _newFeeRecipient) external onlyOwner {
        _salesFeeRecipient = _newFeeRecipient;
    }

    /**
     * @notice Sets market sale fees.
     * @dev Can only be called by the contract owner.
     * @param _newFeeBps Fee BPS for primary and secondary market orders.
     */
    function setMarketFee(uint256 _newFeeBps) external onlyOwner {
        _salesFeeBps = _newFeeBps;
    }

    /**
     * @dev Required getter for reading arrays returned by Order struct.
     * Declaring variable public does not return the array's content.
     * @dev the function returns even if the order of offer does not exist or has been deleted,
     * the frontend should handle this case by checking that the `operator` is not the zero address.
     * @param _orderId The ID of the order.
     * @return Order The order details.
     */
    function getETHOrder(uint256 _orderId) external view returns (Order memory) {
        return _ETHOrders[_orderId];
    }

    function getETHOffer(uint256 _offerId) external view returns (Offer memory) {
        return _ETHOffers[_offerId];
    }

    function getUSDCOrder(uint256 _orderId) external view returns (Order memory) {
        return _USDCOrders[_orderId];
    }

    function getUSDCOffer(uint256 _offerId) external view returns (Offer memory) {
        return _USDCOffers[_offerId];
    }

    /**
     * @dev Checks if the contract supports a specific interface.
     * @notice See {IERC165-supportsInterface}.
     * @param interfaceId The ID of the interface.
     * - For IERC165, interfaceId == 0x01ffc9a7.
     * - For IERC721Receiver, interfaceId == 0x150b7a02. A wallet/broker/auction application
     * MUST implement the wallet interface if it will accept safe transfers.
     * - Return value from `onERC1155Received` call if a contract accepts receipt
     * (i.e `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`).
     * In all other cases the ERC1155TokenReceiver rules MUST be followed as
     * appropriate for the implementation (i.e. safe, custom and/or hybrid).
     * @return bool True if the contract supports the interface, false otherwise.
     */
    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {
        return interfaceId == 0x01ffc9a7 // Interface ID for IERC165
            || interfaceId == 0x150b7a02 // Interface ID for IERC721Receiver.
            || interfaceId == 0x4e2312e0; // `ERC1155TokenReceiver` support (i.e.
            // `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)")) ^
            // bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`).
    }

    function _handleERC1155OrderOrOffer(
        address _from,
        address _operator,
        address[] memory _commissionRecipients,
        uint256 _orderOrOfferId,
        uint256 _unitPrice,
        uint256 _ERC1155Value,
        uint256 _tokenId,
        uint256[] memory _commissionBps,
        QuoteToken _quoteToken
    )
        internal
    {
        if (_orderOrOfferId == 0) {
            /*----------------------------------------------------------*|
            |*  # CREATE ORDER                                          *|
            |*----------------------------------------------------------*/
            // if `_orderOrOfferId` is 0, create a new order, i.e.:
            // `_unitPrice >= 0 && _orderOrOfferId == 0`
            _quoteToken == QuoteToken.ETH
                ? _createETHOrder(
                    _operator, _from, _tokenId, _ERC1155Value, _unitPrice, _commissionBps, _commissionRecipients
                )
                : _createUSDCOrder(
                    _operator, _from, _tokenId, _ERC1155Value, _unitPrice, _commissionBps, _commissionRecipients
                );
        } else if (_unitPrice == 0) {
            /*----------------------------------------------------------*|
            |*  # ACCEPT OFFER                                          *|
            |*----------------------------------------------------------*/
            // if `_unitPrice == 0 && _orderOrOfferId > 0`
            Offer memory offer;

            if (_quoteToken == QuoteToken.ETH) {
                offer = _ETHOffers[_orderOrOfferId];
                // since the calling function is public `msg.sender` must be the same contract address as the one
                // specified by the
                // offer id being accepted.
                // Having verified the collection, verifying the remaining hook's function parameters is not needed,
                // since the it is assumed that they are not user controlled except for `_data` which can be arbitrary.
                require(offer.collection == msg.sender && offer.tokenId == _tokenId);
                // inline subtraction of `_ERC1155Value` from offer amount, transaction will revert
                // if underflow, implicitly requiring `offers[_orderOrOfferId]._ERC1155Value >= _value`
                if ((_ETHOffers[_orderOrOfferId].ERC1155Value -= _ERC1155Value) == 0) {
                    delete _ETHOffers[_orderOrOfferId];
                }

                _handleETHTrade(
                    Order(
                        _tokenId, // uint256 tokenId
                        offer.unitPrice * _ERC1155Value, // uint256 unitPrice
                        _ERC1155Value,
                        msg.sender, // address collection
                        _from, // seller (order.from)
                        offer.from, // buyer (order.operator)
                        _commissionBps, // uint256 _commissionBps
                        _commissionRecipients
                    ),
                    _orderOrOfferId
                );
            } else {
                offer = _USDCOffers[_orderOrOfferId];
                // since the calling function is public `msg.sender` must be the same contract address as the one
                // specified by the
                // offer id being accepted.
                // Having verified the collection, verifying the remaining hook's function parameters is not needed,
                // since the it is assumed that they are not user controlled except for `_data` which can be arbitrary.
                require(offer.collection == msg.sender && offer.tokenId == _tokenId);
                // subtracting `_ERC1155Value` from offer amount, transaction will revert
                // if underflow, implicitly requiring `offers[_orderOrOfferId]._ERC1155Value >= _value`
                if ((_USDCOffers[_orderOrOfferId].ERC1155Value -= _ERC1155Value) == 0) {
                    delete _USDCOffers[_orderOrOfferId];
                }

                _handleUSDCTrade(
                    Order(
                        _tokenId, // uint256 tokenId
                        offer.unitPrice * _ERC1155Value, // uint256 unitPrice
                        _ERC1155Value,
                        msg.sender, // address collection
                        _from, // seller (order.from)
                        offer.from, // buyer (order.operator)
                        _commissionBps, // uint256 _commissionBps
                        _commissionRecipients
                    ),
                    _orderOrOfferId
                );
            }
        } else {
            /*----------------------------------------------------------------------------*|
            |*  # UPDATE ORDER (raise ERC1155 value and optionally set new unit price)    *|
            |*----------------------------------------------------------------------------*/
            // `_unitPrice > 0 && _orderOrOfferId > 0`

            Order storage order;

            _quoteToken == QuoteToken.ETH ? order = _ETHOrders[_orderOrOfferId] : order = _USDCOrders[_orderOrOfferId];

            // collection and tokenId of the NFT received by the
            // marketplace must match the ones stored at
            // the _orderOrOfferId provided by the operator
            // in order to avoid operators increasing allowance for orders with
            // different (more valuable) token ids from the same collection.
            // * collection must match msg.sender or else other function arguments cannot trusted addresses
            // * operators must match or else order.unitPrice could be set by unauthorized
            // * `order.tokenId == _tokenId` prevents the operator from sending a different tokenId,
            //   in order to raise the value of order.ERC1155Value
            require(
                order.operator == _operator
                    && order.collection == msg.sender
                    && order.tokenId == _tokenId
            );

            order.ERC1155Value += _ERC1155Value;

            if (order.unitPrice != _unitPrice) order.unitPrice = _unitPrice; // override old unit price (may not change)

            emit OrderUpdated(_orderOrOfferId, _quoteToken);
        }
    }

    /**
     * @dev ERC-721 tokens are transferred to the buyer via `transferFrom`
     * rather than `safeTransferFrom`.
     * The caller is responsible to confirm that the recipient if a contract is
     * capable of receiving and handling ERC721 and ERC1155 tokens
     * If the minter is a smart contract, it needs to implement onERC721Received (see `ERC721-_mint`),
     * however this is not the case here.
     */
    function _transferNFT(
        address _collection,
        address _from,
        address _to,
        uint256 _tokenId,
        uint256 _ERC1155Value
    )
        internal
    {
        // if the token is an ERC721 token, the ERC1155Value is 0
        // (more gas efficient than using ERC-165 `supportsInterface` external function call)
        if (_ERC1155Value == 0) {
            // low level call custom function imported from `Address` library (without the need for IERC721 interface)
            // `transferFrom` does not transfer data or trigger the `onERC721Received` function
            _collection.transferFrom(_from, _to, _tokenId);
        } else {
            // 0xf242432a is the selector for `safeTransferFrom(address,address,uint256,uint256,bytes)`
            (bool success,) =
                _collection.call(abi.encodeWithSelector(0xf242432a, _from, _to, _tokenId, _ERC1155Value, ""));
            require(success);
        }
    }

    function _createETHOffer(
        uint256 _tokenId,
        uint256 _unitPrice,
        uint256 _ERC1155Value,
        address _collection,
        address _from
    )
        private
    {
        ETHOfferCount.increment(); // start count at 1, not 0

        uint256 offerId = ETHOfferCount.current();

        _ETHOffers[offerId] = Offer(_tokenId, _unitPrice, _ERC1155Value, _collection, _from);
        // @dev keep event emission inside private function, otherwise the event might get triggered even when no
        // if/else condition is met inside the calling function, whereas this function executes in its entirety or not
        // at all
        emit OfferCreated(offerId, QuoteToken.ETH);
    }

    function _createUSDCOffer(
        uint256 _tokenId,
        uint256 _unitPrice,
        uint256 _ERC1155Value,
        uint256 _offerValue,
        address _collection,
        address _from
    )
        private
    {
        USDCOfferCount.increment(); // start count at 1, not 0

        uint256 offerId = USDCOfferCount.current();

        offerId = USDCOfferCount.current();

        _USDC.transferFrom(msg.sender, address(this), _offerValue);

        _USDCOffers[offerId] = Offer(_tokenId, _unitPrice, _ERC1155Value, _collection, _from);

        emit OfferCreated(offerId, QuoteToken.USDC);
    }

    /**
     * @notice Handles the trade process, including payment of marketplace fee, royalties, commissions, and seller.
     * @dev This function is private and can only be called within this contract.
     * @param _order The order to be processed.
     * @param _id The id of the order.
     */
    function _handleETHTrade(Order memory _order, uint256 _id) private {
        // amount owed to seller after fees, royalties (if any) and commissions (if any)
        // the value of `_order.unitPrice` is set to the total price of the order by the calling function,
        // i.e. `_order.unitPrice` * `ERC1155Value`, or just `_order.unitPrice` for ERC721 tokens
        uint256 sellerAmount = _order.unitPrice;

        /*----------------------------------------------------------*|
        |*  # PAY MARKETPLACE FEE                                   *|
        |*----------------------------------------------------------*/

        uint256 marketplaceAmount = (_order.unitPrice * _salesFeeBps) / _TOTAL_BPS;
        // subtracting primary or secondary fee amount from seller
        // amount, this is a security check (will revert
        // on underflow) as well as a variable assignment.
        sellerAmount -= marketplaceAmount; // subtract before external call
        // send ETH to trusted recipient
        _salesFeeRecipient.sendValue(marketplaceAmount);

        /*----------------------------------------------------------*|
        |*  # PAY ROYALTIES (if any)                                *|
        |*----------------------------------------------------------*/

        (address payable[] memory royaltyReceivers, uint256[] memory royaltyAmounts) =
            getRoyalty(_order.collection, _order.tokenId, _order.unitPrice);

        uint256 royaltyReceiversCount = royaltyReceivers.length;

        if (royaltyReceiversCount > 0) {
            // The collection implements some royalty standard, otherwise the length of the arrays returned would be 0.
            address royaltyReceiver;
            uint256 royaltyAmount;
            do {
                royaltyReceiversCount--;
                royaltyAmount = royaltyAmounts[royaltyReceiversCount];
                royaltyReceiver = royaltyReceivers[royaltyReceiversCount];
                // subtract from seller amount before external call to prevent reentrancy
                sellerAmount -= royaltyAmount;
                royaltyReceiver.sendValue(royaltyAmount);
            } while (royaltyReceiversCount > 0);
        }

        /*----------------------------------------------------------*|
        |*  # PAY ORDER COMMISSIONS (if any)                        *|
        |*----------------------------------------------------------*/

        uint256 commissionRecipientLength = _order.commissionRecipient.length;

        if (commissionRecipientLength > 0) {
            do {
                commissionRecipientLength--;
                uint256 commissionAmount =
                    (_order.commissionBps[commissionRecipientLength] * _order.unitPrice) / _TOTAL_BPS;

                sellerAmount -= commissionAmount; // subtract before external call
                _order.commissionRecipient[commissionRecipientLength].sendValue(commissionAmount);
            } while (commissionRecipientLength > 0);
        }

        /*----------------------------------------------------------*|
        |*  # PAY SELLER                                            *|
        |*----------------------------------------------------------*/

        _order.from.sendValue(sellerAmount);

        /*----------------------------------------------------------*|
        |*  # TRANSFER NFT                                          *|
        |*----------------------------------------------------------*/

        _transferNFT(
            _order.collection,
            address(this),
            _order.operator, // buyer
            _order.tokenId,
            _order.ERC1155Value
        );

        /*----------------------------------------------------------*|
        |*  # FIRE EVENT                                            *|
        |*----------------------------------------------------------*/

        emit Trade(
            _order.collection,
            _order.from, // seller
            _order.tokenId,
            _id,
            _order.unitPrice,
            _order.ERC1155Value,
            QuoteToken.ETH
        );
    }

    /**
     * @notice Handles the trade process, including payment of marketplace fee, royalties, commissions, and seller.
     * @dev This function is private and can only be called within this contract.
     * @param _order The order to be processed.
     * @param _id The id of the order.
     */
    function _handleUSDCTrade(Order memory _order, uint256 _id) private {
        // amount owed to seller after fees, royalties (if any) and commissions (if any)
        // the value of `_order.unitPrice` is set to the total price of the order by the calling function,
        // i.e. `_order.unitPrice` * `ERC1155Value`, or just `_order.unitPrice` for ERC721 tokens
        uint256 sellerAmount = _order.unitPrice;

        /*----------------------------------------------------------*|
        |*  # PAY MARKETPLACE FEE                                   *|
        |*----------------------------------------------------------*/

        uint256 marketplaceAmount = (_order.unitPrice * _salesFeeBps) / _TOTAL_BPS;
        // subtracting primary or secondary fee amount from seller
        // amount, this is a security check (will revert
        // on underflow) as well as a variable assignment.
        sellerAmount -= marketplaceAmount; // subtract before external call
        // send USDC to trusted recipient
        _USDC.transferFrom(_order.operator, _salesFeeRecipient, marketplaceAmount);

        /*----------------------------------------------------------*|
        |*  # PAY ROYALTIES (if any)                                *|
        |*----------------------------------------------------------*/

        (address payable[] memory royaltyReceivers, uint256[] memory royaltyAmounts) =
            getRoyalty(_order.collection, _order.tokenId, _order.unitPrice);

        uint256 royaltyReceiversCount = royaltyReceivers.length;

        if (royaltyReceiversCount > 0) {
            // The collection implements some royalty standard, otherwise the length of the arrays returned would be 0.
            address royaltyReceiver;
            uint256 royaltyAmount;
            do {
                royaltyReceiversCount--;
                royaltyAmount = royaltyAmounts[royaltyReceiversCount];
                royaltyReceiver = royaltyReceivers[royaltyReceiversCount];
                // subtract from seller amount before external call to prevent reentrancy
                sellerAmount -= royaltyAmount;

                _USDC.transferFrom(_order.operator, royaltyReceiver, royaltyAmount);
            } while (royaltyReceiversCount > 0);
        }

        /*----------------------------------------------------------*|
        |*  # PAY ORDER COMMISSIONS (if any)                        *|
        |*----------------------------------------------------------*/

        uint256 commissionRecipientLength = _order.commissionRecipient.length;

        if (commissionRecipientLength > 0) {
            do {
                commissionRecipientLength--;
                uint256 commissionAmount =
                    (_order.commissionBps[commissionRecipientLength] * _order.unitPrice) / _TOTAL_BPS;

                sellerAmount -= commissionAmount; // subtract before external call

                _USDC.transferFrom(
                    _order.operator, _order.commissionRecipient[commissionRecipientLength], commissionAmount
                );
            } while (commissionRecipientLength > 0);
        }

        /*----------------------------------------------------------*|
        |*  # PAY SELLER                                            *|
        |*----------------------------------------------------------*/
        _USDC.transferFrom(_order.operator, _order.from, sellerAmount);

        /*----------------------------------------------------------*|
        |*  # TRANSFER NFT                                          *|
        |*----------------------------------------------------------*/

        _transferNFT(
            _order.collection,
            address(this),
            _order.operator, // buyer
            _order.tokenId,
            _order.ERC1155Value
        );

        emit Trade(
            _order.collection,
            _order.from, // seller
            _order.tokenId,
            _id,
            _order.unitPrice,
            _order.ERC1155Value,
            QuoteToken.USDC
        );
    }

    /**
     * @notice Create a new order on the marketplace by transferring an NFT to it.
     * @dev Can only be called by transferring a token to this contract via hooks.
     * @param _operator The address that called safeTransferFrom on the token contract (owner or operator).
     * @param _from The seller's address.
     * @param _id The ID of the NFT.
     * @param _value The value in case it is an ERC1155.
     * @param _unitPrice The total price if ERC721, unit price if ERC1155.
     * @param _commissionBps Array of commission basis points.
     * @param _commissionRecipient Array of addresses to receive commissions.
     */
    function _createETHOrder(
        address _operator,
        address _from,
        uint256 _id,
        uint256 _value,
        uint256 _unitPrice,
        uint256[] memory _commissionBps,
        address[] memory _commissionRecipient
    )
        private
    {
        // `ETHOrderCount` starts at 1, not 0
        ETHOrderCount.increment();
        // get the current order id
        uint256 _orderId = ETHOrderCount.current();
        // if `_from` is the zero address, set it to `_operator`
        // _from can only be 0 if it is a mint from the collection contract, in which case the operator is the seller
        if (_from == address(0)) {
            _from = _operator;
        }
        // create order with new `_orderId` in orders mapping
        _ETHOrders[_orderId] = Order(
            _id,
            _unitPrice,
            _value,
            msg.sender, // collection; msg.sender is the nft contract
            _from,
            _operator,
            _commissionBps,
            _commissionRecipient
        );

        emit OrderCreated(_orderId, QuoteToken.ETH);
    }

    function _createUSDCOrder(
        address _operator,
        address _from,
        uint256 _id,
        uint256 _value,
        uint256 _unitPrice,
        uint256[] memory _commissionBps,
        address[] memory _commissionRecipient
    )
        private
    {
        // `USDCOrderCount` starts at 1, not 0
        USDCOrderCount.increment();
        // get the current order id
        uint256 _orderId = USDCOrderCount.current();
        // if `_from` is the zero address, set it to `_operator`
        // _from can only be 0 if it is a mint from the collection contract, in which case the operator is the seller
        if (_from == address(0)) {
            _from = _operator;
        }

        // create order with new `_orderId` in USDCOorders mapping
        _USDCOrders[_orderId] = Order(
            _id,
            _unitPrice,
            _value,
            msg.sender, // collection; msg.sender is the nft contract
            _from,
            _operator,
            _commissionBps,
            _commissionRecipient
        );

        emit OrderCreated(_orderId, QuoteToken.USDC);
    }
}
